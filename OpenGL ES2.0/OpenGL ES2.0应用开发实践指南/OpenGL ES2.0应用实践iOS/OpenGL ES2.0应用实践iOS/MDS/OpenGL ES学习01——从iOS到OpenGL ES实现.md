### 编程实践

注：项目只适用于iOS13之前

#### 名词解析：
GPU ：图像处理单元
RAM ：随机存取存储器

#### 1  3D渲染
1、屏幕只有2维，用3D数据生成一个2D图像的过程就叫渲染。在计算机上显示的图片是由矩形的颜色点组成的，这些矩形的颜色点叫做像素。

每个像素点由红、绿、蓝三个颜色元素组成。而这3个颜色正好对应3个数值。所以一个像素可以用一个包含三个元素的数组表示。

2、渲染3D主要分为以下几个步骤：
* **为GPU提供要处理的数据**

    OpenGL ES部分运行在CPU上，部分运行在GPU上。OpenGL ES横跨在两个处理器之间，协调两个内存区域（CPU的RAM和GPU的RAM）之间数据的交换。但是数据的交换和内存的访问速度都是巨大的瓶颈。
    因此，OpenGL ES为两个内存区域间的数据交换 定义了一个**缓存**概念。缓存是指图像处理器能够控制和管理的连续RAM。程序从CPU内存中复制数据到OpenGL ES 的缓存中。这样GPU就可以独占缓存单独享用这些资源，以最有效方式读写数据。而CPU因为无需再等待资源，所以可以继续执行其他的程序。
    为缓存提供数据的步骤及对应C语言函数：
    1、生成  glGenBuffers( ) ——请求OpenGL ES为图形处理器控制的缓存生成一个标识符
    2、绑定 glBindBuffer（）——告诉OpenGL ES为接下来的运算使用一个缓存
    3、缓存数据 glBufferData（）或 glBufferSubData（）——为缓存分配并初始化足够连续内存
    4、启用or禁止 glEnableVertexAttribArray（）或 glDisableVertexAttribArray（）告诉OpenGL ES接下来的渲染是否使用缓存中的数据
    5、设置指针 glVertexAttribPointer（）——告诉OpenGL ES在缓存中的数据的类型和访问数据的内存偏移值
    6、绘图 glDrawArrays（）或 glDrawElement（）—— 启用渲染
    7、删除 glDeleteBuffer（）—— 释放缓存资源
    
     在渲染完成后，GPU得需要一个存储渲染结果的2D图像像素数据的地方。这个接收渲染结果的地方就是**帧缓存**区。 
     
     
3、 **OpenGL ES上下文** 
    应该是指整个OpenGL ES的运行程序
    
4、 需要的数据
    1、坐标系：以手机屏幕为例，左下角是圆点，x轴正方向向右，y轴正方向向上，z轴正方向是屏幕正方向。
        2、矢量；
        3、点、线、三角形：OpenGL ES只渲染顶点、线段、三角形。
        

**总结**：
渲染是指把程序提供的几何数据转换成屏幕上图像的过程。渲染主要作用于顶点、线段、三角形。OpenGL ES的坐标系、矢量是几何数据的基础。GPU控制OpenGL ES提供的缓存是高效渲染的关键。渲染的结果通常保存在帧缓存中，有两个特殊的帧缓存:前帧缓存和后帧缓存，它们控制着屏幕像素的最终颜色。OpenGL ES的上下文保存了OpenGL ES的状态信息，包括用于提供渲染数据的缓存地址和用于接收渲染结果的缓存地址。

        
        

#### 2、iOS 中的OpenGL ES基础
Core Animation 是建立在OpenGL ES之上用于创建并管理帧缓存和渲染缓存共享内存的工作。
1、一个iOS应用由应用‘层’和操作系统提供的层混合起来显示外观。比如顶部状态栏是有操作系统生成和控制的层。

**Cocoa Touch** 应用框架：
Cocoa Touch提供了iOS应用的基础结构。基本上所有的组件（包括对硬件的访问：键盘、触摸事件）都是不需要程序员干预的。大部分情况下，只有应用委托（application delegate）和根视图控制器（root view controller）由程序员干预。
* **UIApplication**：每个应用都包含一个单一的UIApplication实例。它提供了应用和iOS系统之间的双向通信。应用向iOS系统请求服务（比如显示方向），系统为应用提供信息。UIApplication会与一个或多个UIWindow实例通信，还会与一个用于路由用户事件到正确对象的委托delegate通信。
* **Appdelegate**：就是UIApplication的委托，主要用来处理关键信息的消息。比如说接收应用运行环境的所有改变，包括应用启动、结束这些信息。
* **UIWindow**：一个应用至少有一个自动创建的覆盖整个屏幕的UIWindow实例。同时也可能其他UIWindow来展示警告和状态信息。UIWindow会包含一个或多个用于展示窗口图形内容的UIView实例。UIWindow的一个重要作用是从UIApplication实例接收用户的事件，然后根据实际情况把事件发送给正确的UIView实例（iOS事件响应流程）。
* **Root View Controller**：每个窗口UIWindow都有一个可选的根视图控制器。视图控制器指定填充整个窗口的UIView实例。**GLKViewController**是支持OpenGL ES特有的行为和动画计时时的UIViewController的内建子类。
* **GLKView**：它是UIView的内建子类。GKLView相关的GLKViewController实例是视图的委托并接收当视图需要重绘时的消息。



#### 3、纹理
名词解析：
* 纹理： 是一个 用来保存图像颜色元素值的OpenGL ES缓存。
* 纹素： 当一个图像初始化一个纹理缓存后，这个图像中的每个像素变成了纹理中的一个纹素。与像素类似，纹素保存颜色数据。
* 视口坐标：OpenGL ES 坐标系中坐标位置所对应的帧缓存中所对应的真实像素位置。**渲染时，GPU将OpenGL ES坐标转换成帧视口坐标后，所有绘制的几何图形都被拉伸以适合屏幕大小**
* 点阵化：视口坐标转换后，GPU会根据几何形状数据转换成帧缓存中的颜色像素（当没有纹理时，会根据每个像素的顶点颜色来计算每个像素的颜色，如果有纹理，则会根据纹理缓存中的纹素来计算每个像素的颜色），这个步骤叫做点阵化。
* 片元：点阵化中每个颜色像素叫做片元。
* 映射：GPU在计算片元颜色时，需要知道纹理和顶点是怎么对齐的，以便知道每个片元的颜色由哪些纹素决定。这个对齐就是映射。
* U、V坐标：（自我理解）映射过程中，有可能一个纹理中的一个实际大小的OpenGL坐标值（或者说一个实际香色）对应视口坐标的几个像素（比如屏幕很大纹理会拉伸的情况下，纹理中的一个像素，可能在视口中被渲染成了几个像素）（可以查看OpenGL_ES_VC03中的代码实现）。
* 取样：GPU在点阵化过程中，就可以用U和V坐标来表示哪些视口像素是实际属于同一个纹理像素的。这样就可能根据U、V坐标确定某个片元绑定了哪些纹素。这个选择过程叫取样。（取样的不准确可能就会导致最终渲染变形、拉伸、压缩等问题）


但是有一个问题，如果纹素比片元更少或更多，那么GPU如何取样，则就得根据程序指定的方式来处理了。glTextParameteri()函数用于指定取样样式和循环模式（循环模式是指重复纹理以填满整个区域），第3个参数决定。它的可能值有：GL_NEARESAT、GL_LINEAR。
    glTextParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,GL_NEARESAT)

* MIP贴图：是一个为纹理存储多个细节级别的技术，使用MIP贴图通常会减少GPU取样的数量，来提供渲染性能，但是所需要的内存会更多。












