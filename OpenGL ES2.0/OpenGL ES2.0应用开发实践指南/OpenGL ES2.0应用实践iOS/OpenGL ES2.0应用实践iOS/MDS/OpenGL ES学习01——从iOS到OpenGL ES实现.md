### 编程实践

注：项目只适用于iOS13之前

#### 名词解析：
GPU ：图像处理单元
RAM ：随机存取存储器

#### 1  3D渲染
1、屏幕只有2维，用3D数据生成一个2D图像的过程就叫渲染。在计算机上显示的图片是由矩形的颜色点组成的，这些矩形的颜色点叫做像素。

每个像素点由红、绿、蓝三个颜色元素组成。而这3个颜色正好对应3个数值。所以一个像素可以用一个包含三个元素的数组表示。

2、渲染3D主要分为以下几个步骤：
* **为GPU提供要处理的数据**

    OpenGL ES部分运行在CPU上，部分运行在GPU上。OpenGL ES横跨在两个处理器之间，协调两个内存区域（CPU的RAM和GPU的RAM）之间数据的交换。但是数据的交换和内存的访问速度都是巨大的瓶颈。
    因此，OpenGL ES为两个内存区域间的数据交换 定义了一个**缓存**概念。缓存是指图像处理器能够控制和管理的连续RAM。程序从CPU内存中复制数据到OpenGL ES 的缓存中。这样GPU就可以独占缓存单独享用这些资源，以最有效方式读写数据。而CPU因为无需再等待资源，所以可以继续执行其他的程序。
    为缓存提供数据的步骤及对应C语言函数：
    1、生成  glGenBuffers( ) ——请求OpenGL ES为图形处理器控制的缓存生成一个标识符
    2、绑定 glBindBuffer（）——告诉OpenGL ES为接下来的运算使用一个缓存
    3、缓存数据 glBufferData（）或 glBufferSubData（）——为缓存分配并初始化足够连续内存
    4、启用or禁止 glEnableVertexAttribArray（）或 glDisableVertexAttribArray（）告诉OpenGL ES接下来的渲染是否使用缓存中的数据
    5、设置指针 glVertexAttribPointer（）——告诉OpenGL ES在缓存中的数据的类型和访问数据的内存偏移值
    6、绘图 glDrawArrays（）或 glDrawElement（）—— 启用渲染
    7、删除 glDeleteBuffer（）—— 释放缓存资源
    
     在渲染完成后，GPU得需要一个存储渲染结果的2D图像像素数据的地方。这个接收渲染结果的地方就是**帧缓存**区。 
     
     
3、 **OpenGL ES上下文** 
    应该是指整个OpenGL ES的运行程序
    
4、 需要的数据
    1、坐标系：以手机屏幕为例，左下角是圆点，x轴正方向向右，y轴正方向向上，z轴正方向是屏幕正方向。
        2、矢量；
        3、点、线、三角形：OpenGL ES只渲染顶点、线段、三角形。
        

**总结**：
渲染是指把程序提供的几何数据转换成屏幕上图像的过程。渲染主要作用于顶点、线段、三角形。OpenGL ES的坐标系、矢量是几何数据的基础。GPU控制OpenGL ES提供的缓存是高效渲染的关键。渲染的结果通常保存在帧缓存中，有两个特殊的帧缓存:前帧缓存和后帧缓存，它们控制着屏幕像素的最终颜色。OpenGL ES的上下文保存了OpenGL ES的状态信息，包括用于提供渲染数据的缓存地址和用于接收渲染结果的缓存地址。

        
        

#### 2、iOS 中的OpenGL ES基础
Core Animation 是建立在OpenGL ES之上用于创建并管理帧缓存和渲染缓存共享内存的工作。
1、一个iOS应用由应用‘层’和操作系统提供的层混合起来显示外观。比如顶部状态栏是有操作系统生成和控制的层。

**Cocoa Touch** 应用框架：
Cocoa Touch提供了iOS应用的基础结构。基本上所有的组件（包括对硬件的访问：键盘、触摸事件）都是不需要程序员干预的。大部分情况下，只有应用委托（application delegate）和根视图控制器（root view controller）由程序员干预。
* **UIApplication**：每个应用都包含一个单一的UIApplication实例。它提供了应用和iOS系统之间的双向通信。应用向iOS系统请求服务（比如显示方向），系统为应用提供信息。UIApplication会与一个或多个UIWindow实例通信，还会与一个用于路由用户事件到正确对象的委托delegate通信。
* **Appdelegate**：就是UIApplication的委托，主要用来处理关键信息的消息。比如说接收应用运行环境的所有改变，包括应用启动、结束这些信息。
* **UIWindow**：一个应用至少有一个自动创建的覆盖整个屏幕的UIWindow实例。同时也可能其他UIWindow来展示警告和状态信息。UIWindow会包含一个或多个用于展示窗口图形内容的UIView实例。UIWindow的一个重要作用是从UIApplication实例接收用户的事件，然后根据实际情况把事件发送给正确的UIView实例（iOS事件响应流程）。
* **Root View Controller**：每个窗口UIWindow都有一个可选的根视图控制器。视图控制器指定填充整个窗口的UIView实例。**GLKViewController**是支持OpenGL ES特有的行为和动画计时时的UIViewController的内建子类。
* **GLKView**：它是UIView的内建子类。GKLView相关的GLKViewController实例是视图的委托并接收当视图需要重绘时的消息。



#### 3、纹理
名词解析：
* 纹理： 是一个 用来保存图像颜色元素值的OpenGL ES缓存。
* 纹素： 当一个图像初始化一个纹理缓存后，这个图像中的每个像素变成了纹理中的一个纹素。与像素类似，纹素保存颜色数据。
* 视口坐标：OpenGL ES 坐标系中坐标位置所对应的帧缓存中所对应的真实像素位置。**渲染时，GPU将OpenGL ES坐标转换成帧视口坐标后，所有绘制的几何图形都被拉伸以适合屏幕大小**
* 点阵化：视口坐标转换后，GPU会根据几何形状数据转换成帧缓存中的颜色像素（当没有纹理时，会根据每个像素的顶点颜色来计算每个像素的颜色，如果有纹理，则会根据纹理缓存中的纹素来计算每个像素的颜色），这个步骤叫做点阵化。
* 片元：点阵化中每个颜色像素叫做片元。
* 映射：GPU在计算片元颜色时，需要知道纹理和顶点是怎么对齐的，以便知道每个片元的颜色由哪些纹素决定。这个对齐就是映射。
* U、V坐标：（自我理解）映射过程中，有可能一个纹理中的一个实际大小的OpenGL坐标值（或者说一个实际香色）对应视口坐标的几个像素（比如屏幕很大纹理会拉伸的情况下，纹理中的一个像素，可能在视口中被渲染成了几个像素）（可以查看OpenGL_ES_VC03中的代码实现）。
* 取样：GPU在点阵化过程中，就可以用U和V坐标来表示哪些视口像素是实际属于同一个纹理像素的。这样就可能根据U、V坐标确定某个片元绑定了哪些纹素。这个选择过程叫取样。（取样的不准确可能就会导致最终渲染变形、拉伸、压缩等问题）


但是有一个问题，如果纹素比片元更少或更多，那么GPU如何取样，则就得根据程序指定的方式来处理了。glTextParameteri()函数用于指定取样样式和循环模式（循环模式是指重复纹理以填满整个区域），第3个参数决定。它的可能值有：GL_NEARESAT、GL_LINEAR。
    glTextParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,GL_NEARESAT)

* MIP贴图：是一个为纹理存储多个细节级别的技术，使用MIP贴图通常会减少GPU取样的数量，来提供渲染性能，但是所需要的内存会更多。


* 混合：通常一个或多个纹素会结合灯光和顶点颜色来决定每个片元的最终颜色和透明度。每个片元产生的透明度都会影响片元怎么与一个帧缓存内的现存内容想混合。当纹理计算出一个完全不透明的最终片元颜色时，这个片元颜色会替换任何在帧缓存的像素颜色渲染缓存内现存的像素颜色，如果计算出来的片元颜色部分透明或者完全透明OpenGL ES会使用一个混合函数来混合片元颜色与像素颜色缓存内对应的像素。实例OpenGL_ES_VC04实现了这种多种纹理混合的方案。这种方式每次的都会重复“读取缓存数据、与片元颜色混合、重写”这个过程。这种方式叫“多通道渲染”。但是内存访问限制了性能，所以这不是最优的方式。

* 多重纹理 ：GLKBaseEffect类同时支持两种纹理texture2d0和texture2d1。OpenGL_ES_VC05显示了这种操作的可行性。

* 自定义纹理：不是很明白那些代码是干嘛的😳。


#### 4、光线
OpenGL ES的灯光模拟由每个光源的三个截然不同的部分组成：环境光、漫反射光、镜面反射光。
* 环境光来自各个方向，因此会等同地增强所有几何图形的亮度，程序通过设置模拟环境光的颜色和亮度来设置场景中的背景灯光的基础水平。环境光的颜色会着色所有的几何图形，因此一个红色的环境光会让场景中的所有几何图形对象显现红色或者粉红色。
* 漫反射光线是定向的，会基于三角形相对于光线的方向来照亮场景的每个三角形。所以垂直于光线方向的三角形会被剧烈照射，显得灯光通明，如果三角形是平行或背离光线方向，那几乎没有任何光线会照射到。所以漫反射光的颜色只会着色被定向的光线照射到的三角形。
* 从几何图形反射出来的光线叫做镜面反射光，镜面物体会反射大量的光线，但是钝面的物体不会。所以镜面反射光的感知亮度由照射到每个三角形上的光线的量和三角形的反光度决定。镜面反射部分的颜色决定了闪光点的颜色。

一个渲染三角形中的每个光线组成部分的效果取决于三个相互关联的因素：光线的设置、三角形相对于光线的方向、三角形的材质属性。














